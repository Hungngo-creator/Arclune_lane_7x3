<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Arclune Lane 7×3 — v0.6a (khung + cost + summon)</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
<style>
  html,body{margin:0;height:100%;background:#0f1012;color:#e7e7ea;font-family:system-ui, Arial}
  #game{width:100vw;height:100vh;display:block}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ===================== DATA: class/rarity/roster ===================== */
const CLASS_BASE_COST = { tanker:9, warrior:8, assassin:8, mage:9, support:8, summoner:10 };
const RARITY_COST = { N:0.8, R:1.0, SR:1.15, SSR:1.3, UR:1.55, Prime:1.9 };

const ROSTER = [
  {id:'phe', name:'Phệ', class:'summoner', rarity:'Prime', range:2, color:0xC0353A},
  {id:'kiem-truong-da', name:'Kiếm Trường Dạ', class:'warrior', rarity:'Prime', range:1, color:0x3FA7F5},
  {id:'loi-thien-anh', name:'Lôi Thiên Ảnh', class:'tanker', rarity:'UR', range:1, color:0x7B5CFF},
  {id:'la-ky', name:'La Kỳ', class:'support', rarity:'SSR', range:2, color:0xFF7FCF},
  {id:'doan-minh', name:'Doãn Minh', class:'support', rarity:'SR', range:2, color:0x6BE3C1},
  {id:'ky-dieu', name:'Kỳ Diêu', class:'summoner', rarity:'SR', range:2, color:0x8BC34A, tags:{revive:true}},
  {id:'tran-quat', name:'Trần Quát', class:'summoner', rarity:'R', range:1, color:0xFFB84D, tags:{summon2plus:true}},
  {id:'linh-gac', name:'Lính Gác', class:'warrior', rarity:'N', range:1, color:0xB0BEC5},
];
// Leader luôn sẵn sàng trên sân, không tính cost
const LEADER = {id:'uyen', name:'Uyên (Leader)', class:'support', rarity:'Prime', range:2, color:0x66D1FF, isLeader:true};

function calcCost(u){
  if(u.isLeader) return 0;
  let base = CLASS_BASE_COST[u.class] ?? 8;
  let m = RARITY_COST[u.rarity] ?? 1.0;
  let cost = Math.ceil(base * m);
  if((u.range||1) >= 2) cost += 1;
  if(u.tags?.summon2plus) cost += 2;
  if(u.tags?.revive) cost += 1;
  cost = Math.max(6, Math.min(20, cost));
  return cost;
}

/* ===================== GAME CONST ===================== */
const GRID_COLS = 7, GRID_ROWS = 3;
const ALLY_COL_MAX = 2; // 3 cột bên trái
const ENEMY_COL_MIN = 4; // 3 cột bên phải
const TILE_W = 96, TILE_H = 54; // iso size
const COST_CAP = 30;
const SUMMON_LIMIT = 10;

/* ===================== PHASER SETUP ===================== */
const config = {
  type: Phaser.CANVAS,
  canvas: document.getElementById('game'),
  backgroundColor: '#0f1012',
  scale: { mode: Phaser.Scale.RESIZE },
  scene: { preload, create, update }
};
const game = new Phaser.Game(config);

function preload(){}

let g; // Graphics
let originX, originY;
let cells = []; // occupancy map
let costNow = 0, lastCostTick = 0;
let hudText, costText, summonText, timerText;
let benchGroup;
let dragGhost = null;
let dragData = null;
let summonsUsed = 0;
let matchMs = 0;
let leaderObj = null;

function create(){
  const W = this.scale.gameSize.width, H = this.scale.gameSize.height;
  g = this.add.graphics();

  // compute iso origin (center grid slightly up)
  originX = W*0.5;
  originY = H*0.48 - (GRID_COLS+GRID_ROWS)*(TILE_H/4);

  // occupancy init
  for(let r=0;r<GRID_ROWS;r++){
    cells[r] = [];
    for(let c=0;c<GRID_COLS;c++) cells[r][c] = null;
  }

  drawGrid(this);

  // spawn Leader at (col=0,row=1)
  leaderObj = spawnUnitOnCell(this, LEADER, 0, 1, true);

  // HUD
  hudText = this.add.text(16,16,
    "Kéo thẻ để thả vào 3 cột bên trái.\n0.6a: khung + cost + summon (chưa combat).",
    {fontSize: '16px', color:'#e7e7ea'});
  costText = this.add.text(16, H-96, "", {fontSize:'18px', color:'#ffd166'});
  summonText = this.add.text(16, H-72, "", {fontSize:'16px', color:'#a0e7a0'});
  timerText  = this.add.text(W-140, 16, "00:00", {fontSize:'18px', color:'#bde0fe'});

  // BENCH
  benchGroup = this.add.container(0, H-56);
  buildBench(this);

  updateHUD();
  this.input.on('dragstart', onDragStart, this);
  this.input.on('drag', onDrag, this);
  this.input.on('dragend', onDragEnd, this);
}

function update(time, delta){
  matchMs += delta;
  timerText.setText(formatTime(matchMs));

  // cost tick mỗi 1000ms
  if(time - lastCostTick >= 1000){
    lastCostTick = time;
    if(costNow < COST_CAP){ costNow += 1; updateHUD(); refreshBenchState(); }
  }
}

/* ===================== GRID / ISO ===================== */
function isoX(col,row){ return originX + (col - row) * (TILE_W/2); }
function isoY(col,row){ return originY + (col + row) * (TILE_H/2); }

function drawDiamond(scene, col, row, color, alpha=1.0, lineAlpha=0.12){
  const x = isoX(col,row), y = isoY(col,row);
  const w = TILE_W/2, h = TILE_H/2;
  g.lineStyle(1, 0xffffff, lineAlpha);
  g.fillStyle(color, alpha);
  g.beginPath();
  g.moveTo(x, y-h);
  g.lineTo(x+w, y);
  g.lineTo(x, y+h);
  g.lineTo(x-w, y);
  g.closePath();
  g.fillPath();
  g.strokePath();
}

function drawGrid(scene){
  g.clear();
  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      let tint = 0x1a1b1e;
      if(c<=ALLY_COL_MAX) tint = 0x1d2a2f;         // ally zone
      else if(c>=ENEMY_COL_MIN) tint = 0x2a1d1d;   // enemy zone
      drawDiamond(scene, c, r, tint, 1.0, 0.10);
    }
  }
}

/* ===================== UNITS & BENCH ===================== */
function spawnUnitOnCell(scene, unit, col, row, isLeader=false){
  const x = isoX(col,row), y = isoY(col,row);

  // mark occupied
  cells[row][col] = unit.id;

  // chibi placeholder
  const body = scene.add.rectangle(x, y-6, 26, 28, unit.color, 1).setOrigin(0.5,1);
  const head = scene.add.ellipse(x, y-34, 18, 16, 0xf5f5f5, 1);
  // vũ khí/đồ nghề đơn giản
  const wep = scene.add.rectangle(x+14, y-18, 16, 4, 0xeeeeee, 1).setRotation(-0.3);

  const name = scene.add.text(x, y+12, unit.isLeader ? unit.name : shortName(unit.name),
    {fontSize:'12px', color:'#e7e7ea'}).setOrigin(0.5,0.5);

  const container = scene.add.container(0,0,[body, head, wep, name]);
  container.setData({col,row,id:unit.id,isLeader});
  return container;
}

function shortName(s){ return s.length>10 ? s.slice(0,10)+'…' : s; }

function buildBench(scene){
  const pad = 8, cardW = 92, cardH = 48;
  let x = pad;
  const units = ROSTER.map(u => ({...u, cost: calcCost(u)}));
  units.forEach(u=>{
    const card = scene.add.container(x, 0);
    const bg = scene.add.rectangle(0,0, cardW, cardH, 0x24262b, 1).setOrigin(0,0).setStrokeStyle(1,0x3a3d44,1);
    const chip = scene.add.rectangle(8, cardH/2, 10, 28, u.color, 1).setOrigin(0,0.5);
    const name = scene.add.text(24, 6, shortName(u.name), {fontSize:'12px', color:'#e7e7ea'});
    const cost = scene.add.text(24, 26, `Cost ${u.cost}`, {fontSize:'12px', color:'#ffd166'});
    card.add([bg, chip, name, cost]);
    card.setSize(cardW, cardH);
    card.setData({unit:u, used:false});
    card.setInteractive(new Phaser.Geom.Rectangle(0,0,cardW,cardH), Phaser.Geom.Rectangle.Contains);
    scene.input.setDraggable(card);
    benchGroup.add(card);
    x += cardW + pad;
  });
  refreshBenchState();
}

function refreshBenchState(){
  benchGroup.iterate(card=>{
    const {unit, used} = card.getData();
    const bg = card.list[0];
    const dim = used || unit.cost>costNow || summonsUsed>=SUMMON_LIMIT;
    bg.setFillStyle(dim?0x1a1c20:0x24262b,1);
    card.alpha = used?0.45:1;
    card.input && (card.input.draggable = !used);
  });
}

function onDragStart(pointer, gameObject){
  const data = gameObject.getData && gameObject.getData('unit');
  if(!data) return;
  if(gameObject.getData('used')) return;
  if(data.cost>costNow){ flashNote(this, "Chưa đủ cost."); return; }
  if(summonsUsed>=SUMMON_LIMIT){ flashNote(this, "Đã đạt 10 lần triệu hồi."); return; }

  dragData = data;
  const W = this.scale.gameSize.width, H = this.scale.gameSize.height;
  dragGhost = this.add.container(pointer.worldX, pointer.worldY);
  const r = this.add.rectangle(0,0, 70, 32, 0x2b2d33, 0.95).setOrigin(0.5,0.5).setStrokeStyle(1,0x3a3d44,1);
  const t = this.add.text(0,0, `${shortName(data.name)}\nCost ${data.cost}`, {fontSize:'12px', color:'#e7e7ea'}).setOrigin(0.5,0.5).setAlign('center');
  dragGhost.add([r,t]);
}
function onDrag(pointer, gameObject, dragX, dragY){
  if(dragGhost) dragGhost.setPosition(pointer.worldX, pointer.worldY);
}
function onDragEnd(pointer, gameObject){
  if(!dragGhost){ return; }
  const drop = pickCell(pointer.worldX, pointer.worldY);
  dragGhost.destroy(); dragGhost=null;

  if(!drop.hit){ flashNote(this,"Thả vào ô hợp lệ (3 cột bên trái)."); return; }
  const {col,row} = drop;
  if(col>ALLY_COL_MAX){ flashNote(this,"Chỉ được thả trong 3 cột bên trái."); return; }
  if(cells[row][col]){ flashNote(this,"Ô đã có đơn vị."); return; }
  // chặn ô leader đang đứng
  if(leaderObj && leaderObj.getData('col')===col && leaderObj.getData('row')===row){
    flashNote(this,"Ô của Leader."); return;
  }
  // thanh toán & spawn
  const card = gameObject;
  const u = card.getData('unit');
  if(u.cost>costNow){ flashNote(this,"Chưa đủ cost."); return; }
  costNow -= u.cost; summonsUsed += 1; updateHUD();

  spawnUnitOnCell(this, u, col, row, false);
  card.setData('used', true);
  refreshBenchState();
}

function pickCell(wx, wy){
  // duyệt thô từng ô (nhỏ, GRID 21 ô) → đủ nhanh
  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      const x = isoX(c,r), y = isoY(c,r);
      const w = TILE_W/2, h = TILE_H/2;
      if(pointInDiamond(wx, wy, x,y,w,h)) return {hit:true,col:c,row:r};
    }
  }
  return {hit:false};
}
function pointInDiamond(px,py,cx,cy,hw,hh){
  // |x|/hw + |y|/hh <= 1 (quy chiếu diamond)
  const dx = Math.abs(px-cx), dy = Math.abs(py-cy);
  return (dx/hw + dy/hh) <= 1.0;
}

/* ===================== HUD/MISC ===================== */
function updateHUD(){
  costText.setText(`Cost: ${costNow}/${COST_CAP}`);
  summonText.setText(`Đã triệu hồi: ${summonsUsed}/${SUMMON_LIMIT}`);
}

function flashNote(scene, msg){
  const t = scene.add.text(scene.scale.gameSize.width/2, 40, msg,
    {fontSize:'16px', color:'#ffe066', backgroundColor:'#2b2d33'}).setOrigin(0.5,0.5);
  scene.tweens.add({targets:t, alpha:0, duration:900, onComplete:()=>t.destroy()});
}

function formatTime(ms){
  const s = Math.floor(ms/1000);
  const m = Math.floor(s/60);
  const r = s%60;
  return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
}
</script>
</body>
</html>
